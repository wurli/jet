local engine = require("jet.rust")
local utils = require("jet.utils")

---@alias Jet.Execution.TextOutput string
---@alias Jet.Repl.Bufnr number
---@alias Jet.Repl.Channel number

---@class Jet.Kernel
---The kernel's unique Id, generated by the Rust engine when the kernel starts
---@field id Jet.Kernel.Id
---The filetype associated with the kernel's language
---@field filetype string
---The history of executed code snippets
---@field history string[][]
---The current index in the history.
---@field history_index number
---Information about the kernel
---@field info Jet.Kernel.Info
---The REPL input window number
---@field repl_output_bufnr Jet.Repl.Bufnr
---The REPL output window number
---@field repl_channel Jet.Repl.Channel
---The namespace for virtual text indent text
---@field _ns number
local jet_kernel = {}
jet_kernel.__index = jet_kernel

setmetatable(jet_kernel, {
    __call = function(self, ...)
        return self.new(...)
    end
})

---@param spec_path Jet.Kernel.Spec.Path
function jet_kernel.new(spec_path)
    local self = setmetatable({}, jet_kernel)
    self.history = {}
    self._ns = vim.api.nvim_create_namespace("jet_indent")
    self:_init_repl()
    self:open_repl()
    self.id, self.info = engine.start_kernel(spec_path)
    self:_set_filetype()
    self:_handle_text_output(self.info.banner)
    return self
end

---@param code string[]
function jet_kernel:execute(code)
    if not self.id then
        error("Kernel is not active; use `start()` to activate the kernel.")
    end

    local callback = engine.execute_code(self.id, table.concat(code, "\n"), {})
    table.insert(self.history, {})
    self.history_index = #self.history + 1

    utils.listen(callback, {
        action = function(res)
            return res.status == "idle" and "exit"
                or res.data and "handle"
                or "retry"
        end,
        handler = function(res) self:_handle_result(res) end,
        interval = 50,
    })
end

function jet_kernel:open_repl()
    self.repl_output_winnr = vim.api.nvim_open_win(self.repl_output_bufnr, true, {
        split = "right"
    })

    self.repl_input_winnr = vim.api.nvim_open_win(self.repl_input_bufnr, true, {
        relative = "win",
        win = self.repl_output_winnr,
        col = 1,
        height = 1,
        row = vim.api.nvim_win_get_height(self.repl_output_winnr) - 1,
        width = vim.api.nvim_win_get_width(self.repl_output_winnr),
        border = "none"
    })

    self:_set_indent(">", 0)

    vim.wo[self.repl_output_winnr].number = false
    vim.wo[self.repl_output_winnr].relativenumber = false
    vim.wo[self.repl_output_winnr].listchars = ""
    vim.wo[self.repl_input_winnr].number = false
    vim.wo[self.repl_input_winnr].relativenumber = false
    vim.wo[self.repl_input_winnr].cursorline = false

    -- vim.bo[self.repl_input_bufnr].filetype = "R"
end

function jet_kernel:_init_repl()
    if self.repl_output_bufnr then
        print("REPL output buffer already exists!")
    else
        self.repl_output_bufnr = vim.api.nvim_create_buf(false, true)
        vim.bo[self.repl_output_bufnr].modifiable = false
    end

    if self.repl_input_bufnr then
        print("REPL input buffer already exists!")
    else
        self.repl_input_bufnr = vim.api.nvim_create_buf(false, true)
        vim.keymap.set(
            { "n", "i" }, "<CR>",
            function() self:_try_send_input() end,
            { buffer = self.repl_input_bufnr }
        )
    end

    if self.repl_channel then
        print("REPL channel already exists!")
    else
        self.repl_channel = vim.api.nvim_open_term(self.repl_output_bufnr, {})
    end

    -- TODO: Improve keymaps
    for _, key in ipairs({ "i", "I", "a", "A", "c", "C", "s", "S", "o", "O", "p", "P" }) do
        vim.keymap.set("n", key, function()
            self:_with_input_win(function(winnr)
                vim.api.nvim_set_current_win(winnr)
                vim.cmd.normal(key)
            end)
        end, { buffer = self.repl_output_bufnr })
    end

    vim.keymap.set({ "n", "i" }, "<c-p>", function()
        self:_set_prompt(self:_get_history(-1) or {})
    end, { buffer = self.repl_input_bufnr })

    vim.keymap.set({ "n", "i" }, "<c-n>", function()
        self:_set_prompt(self:_get_history(1) or {})
    end, { buffer = self.repl_input_bufnr })

    vim.api.nvim_create_autocmd("WinClosed", {
        buffer = self.repl_output_bufnr,
        callback = function()
            self:_with_input_win(function(winnr)
                vim.api.nvim_win_close(winnr, true)
            end)
        end
    })

    vim.api.nvim_create_autocmd("WinResized", {
        callback = function()
            if not vim.api.nvim_win_is_valid(self.repl_input_winnr) or
                not vim.api.nvim_win_is_valid(self.repl_output_winnr) then
                return
            end
            if vim.api.nvim_get_current_win() == self.repl_input_winnr then
                vim.api.nvim_win_set_config(
                    self.repl_output_winnr,
                    {
                        width = vim.api.nvim_win_get_width(self.repl_input_winnr),
                    }
                )
            else
                vim.api.nvim_win_set_config(
                    self.repl_input_winnr,
                    {
                        relative = "win",
                        win = self.repl_output_winnr,
                        col = 1,
                        height = 1,
                        row = vim.api.nvim_win_get_height(self.repl_output_winnr) - 1,
                        width = vim.api.nvim_win_get_width(self.repl_output_winnr),
                    }
                )
            end
        end
    })
end

function jet_kernel:_try_send_input()
    local code = table.concat(
        vim.api.nvim_buf_get_lines(self.repl_input_bufnr, 0, -1, false),
        "\n"
    )
    local callback = engine.is_complete(self.id, code)

    utils.listen(callback, {
        action = function(res)
            return res.status == "idle" and "exit"
                or res.type == "is_complete_reply" and "handle"
                or "retry"
        end,
        -- TODO: add a timeout here
        ---@param res Jet.Callback.IsComplete.Result
        handler = function(res)
            if res.data.status == "incomplete" then
                self:_continue_input(res.data.indent)
            else
                self:_send_input()
            end
        end,
        interval = 10,
    })
end

function jet_kernel:_send_input()
    local code = vim.api.nvim_buf_get_lines(self.repl_input_bufnr, 0, -1, false)
    self:_clear_indent(1, -1)
    vim.api.nvim_buf_set_lines(self.repl_input_bufnr, 0, -1, false, {})
    self:execute(code)
    vim.api.nvim_win_set_config(self.repl_input_winnr, { height = 1 })
end

function jet_kernel:_continue_input(indent)
    local last_line = vim.fn.line("$") + 1
    vim.api.nvim_buf_set_lines(self.repl_input_bufnr, -1, -1, true, { "" })
    self:_set_indent((indent or "+") .. "  ", last_line - 1)
    vim.api.nvim_buf_call(self.repl_input_bufnr, function() vim.fn.cursor(last_line, 0) end)
    vim.api.nvim_win_set_config(self.repl_input_winnr, { height = last_line })
end

---@param fn fun(bufnr: number?)
function jet_kernel:_with_input_buf(fn)
    if vim.api.nvim_buf_is_valid(self.repl_input_bufnr) then
        fn(self.repl_input_bufnr)
    end
end

---@param fn fun(bufnr: number?)
function jet_kernel:_with_output_buf(fn)
    if vim.api.nvim_buf_is_valid(self.repl_output_bufnr) then
        fn(self.repl_output_bufnr)
    end
end

---@param fn fun(winnr: number?)
function jet_kernel:_with_input_win(fn)
    if vim.api.nvim_win_is_valid(self.repl_input_winnr) then
        fn(self.repl_input_winnr)
    end
end

---@param fn fun(winnr: number?)
function jet_kernel:_with_output_win(fn)
    if vim.api.nvim_win_is_valid(self.repl_output_winnr) then
        fn(self.repl_output_winnr)
    end
end

---@param msg Jet.Callback.Execute.Result
function jet_kernel:_handle_result(msg)
    if not msg.data then
        return
    end

    if msg.type == "execute_input" then
        self:_handle_text_output("> " .. msg.data.code .. "\n")
    elseif msg.type == "execute_result" then
        self:_handle_text_output(msg.data.data["text/plain"] .. "\n")
    elseif msg.type == "stream" then
        self:_handle_text_output(msg.data.text)
    elseif msg.type == "error" then
        self:_handle_text_output(msg.data.evalue .. "\n")
    elseif msg.type == "input_request" then
        self:_handle_text_output(msg.data.prompt)
    elseif msg.type == "display_data" then
        self:_handle_text_output(vim.inspect(msg.data) .. "\n\n")
    end

    self:_scroll_to_end()
end

---@param indent string
---@param lnum number
function jet_kernel:_set_indent(indent, lnum)
    self:_with_input_buf(function(input_buf)
        vim.api.nvim_buf_set_extmark(input_buf, self._ns, lnum, 0, {
            -- TODO: add Jet highlight groups
            virt_text = { { indent .. " ", "FloatTitle" } },
            virt_text_pos = "inline",
            right_gravity = false,
        })
    end)
end

---@param line_start number
---@param line_end number
function jet_kernel:_clear_indent(line_start, line_end)
    self:_with_input_buf(function(input_buf)
        vim.api.nvim_buf_clear_namespace(input_buf, self._ns, line_start, line_end)
    end)
end

---@param prompt string[]
function jet_kernel:_set_prompt(prompt)
    if not prompt then
        return
    end
    self:_clear_indent(1, -1)
    vim.api.nvim_buf_set_lines(self.repl_input_bufnr, 0, -1, false, prompt)
end

---@param increment number
function jet_kernel:_get_history(increment)
    local new_index = self.history_index + increment
    local entry = self.history[new_index]
    if not entry then
        return
    end
    self.history_index = new_index
    return self.history[self.history_index]
end

function jet_kernel:_scroll_to_end()
    self:_with_output_buf(function(output_buf)
        vim.api.nvim_buf_call(output_buf, function()
            vim.fn.cursor(vim.fn.line("$"), 0)
        end)
    end)
end

function jet_kernel:_set_filetype()
    self.filetype = utils.ext_to_filetype(self.info.language.file_extension)
        or self.info.language.name
        or self.info.language.file_extension
    vim.bo[self.repl_input_bufnr].filetype = self.filetype
end

---@param text string
function jet_kernel:_handle_text_output(text)
    if not text then
        return
    end

    vim.api.nvim_chan_send(self.repl_channel, text)
end

return jet_kernel
