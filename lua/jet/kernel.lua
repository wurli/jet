local engine = require("jet.rust")
local utils = require("jet.utils")
local state = require("jet.state")

---@class Jet.Kernel
---
---The kernel's unique Id, generated by the Rust engine when the kernel starts
---@field id Jet.Kernel.Id
---
---The filetype associated with the kernel's language
---@field filetype string
---
---The history of executed code snippets
---@field history string[][]
---
---The current index in the history.
---@field history_index number
---
---Information about the kernel
---@field info Jet.Kernel.Info
---
---The REPL input buffer number
---@field repl_input_bufnr number
---
---The REPL input window number
---@field repl_input_winnr number
---
---The REPL input window number
---@field repl_output_bufnr number
---
---The REPL input window number
---@field repl_output_winnr number
---
---The REPL background buffer number
---@field repl_background_bufnr number
---
---The REPL background window number
---@field repl_background_winnr number
---
---The REPL output channel
---@field repl_channel number
---
---The augroup for autocommands
---@field _augroup number
---
---@field indent { input: string, continue: string }
---
---The namespace for virtual text indent text
---@field _ns number
local jet_kernel = {}
jet_kernel.__index = jet_kernel

setmetatable(jet_kernel, {
    __call = function(self, ...)
        return self.new(...)
    end
})

---@param spec_path Jet.Kernel.Spec.Path
function jet_kernel.new(spec_path)
    local self = setmetatable({}, jet_kernel)
    self.history = {}
    self.indent = vim.tbl_deep_extend("keep", self.indent or {}, {
        input = ">",
        continue = "+",
    })
    self._ns = vim.api.nvim_create_namespace("jet_repl")
    self._augroup = vim.api.nvim_create_augroup("jet_repl", {})
    self:_init_repl()
    self:open_repl()
    self.id, self.info = engine.start_kernel(spec_path)
    self:_set_title()
    self:_set_filetype()
    self:_display_repl_text(self.info.banner)
    return self
end

---@param code string[]
function jet_kernel:execute(code)
    if not self.id then
        error("Kernel is not active; use `start()` to activate the kernel.")
    end

    local callback = engine.execute_code(self.id, table.concat(code, "\n"), {})
    table.insert(self.history, {})
    self.history_index = #self.history + 1

    utils.listen(callback, {
        action = function(res)
            return res.status == "idle" and "exit"
                or res.data and "handle"
                or "retry"
        end,
        handler = function(res) self:_handle_result(res) end,
        on_exit = function() self:_display_repl_text("\n") end,
        interval = 50,
    })
end

function jet_kernel:open_repl()
    self.repl_background_winnr = vim.api.nvim_open_win(self.repl_background_bufnr, false, {
        split = "right",
        focusable = false
    })

    -- ╭─────╮
    -- │ box │
    -- ╰─────╯

    self.repl_output_winnr = vim.api.nvim_open_win(self.repl_output_bufnr, false, {
        relative = "win",
        win = self.repl_background_winnr,
        col = 0,
        row = 0,
        height = vim.api.nvim_win_get_height(self.repl_background_winnr) - 5,
        width = vim.api.nvim_win_get_width(self.repl_background_winnr),
        border = { "╭", "─", "╮", "│", "│", " ", "│", "│" },
        zindex = 10,
        style = "minimal",
    })

    self.repl_input_winnr = vim.api.nvim_open_win(self.repl_input_bufnr, false, {
        relative = "win",
        win = self.repl_background_winnr,
        height = 1,
        col = 1,
        row = vim.api.nvim_win_get_height(self.repl_background_winnr),
        width = vim.api.nvim_win_get_width(self.repl_background_winnr),
        border = { "│", "─", "│", "│", "╯", "─", "╰", "│" },
        zindex = 20,
        style = "minimal",
    })

    vim.wo[self.repl_output_winnr].listchars = ""
end

function jet_kernel:_init_repl()
    -- Create REPL buffers (if they don't already exist)
    for _, jet_ui in ipairs({ "background", "input", "output" }) do
        local buf_name = "repl_" .. jet_ui .. "_bufnr"
        if self[buf_name] and vim.api.nvim_buf_is_valid(self[buf_name]) then
            print("REPL " .. buf_name .. " buffer already exists")
        else
            local buf = vim.api.nvim_create_buf(false, true)
            self[buf_name] = buf
            vim.bo[buf].buftype = "nofile"
            vim.b[buf].jet = { type = "repl_" .. jet_ui }
        end
    end

    -- Jet sends output from the kernel to a terminal channel in order to
    -- format ansi formatting.
    if self.repl_channel then
        print("REPL output channel already exists!")
    else
        self.repl_channel = vim.api.nvim_open_term(self.repl_output_bufnr, {})
    end

    self:_reset_indent()

    vim.keymap.set(
        { "n", "i" }, "<CR>",
        function() self:_try_send_input() end,
        { buffer = self.repl_input_bufnr }
    )

    -- TODO: Improve keymaps
    for _, key in ipairs({ "i", "I", "a", "A", "c", "C", "s", "S", "o", "O", "p", "P" }) do
        vim.keymap.set("n", key, function()
            self:_with_input_win(function(winnr)
                vim.api.nvim_set_current_win(winnr)
                vim.cmd.normal(key)
            end)
        end, { buffer = self.repl_output_bufnr })
    end

    vim.keymap.set({ "n", "i" }, "<c-p>", function()
        self:_set_prompt(self:_get_history(-1) or {})
    end, { buffer = self.repl_input_bufnr })

    vim.keymap.set({ "n", "i" }, "<c-n>", function()
        self:_set_prompt(self:_get_history(1) or {})
    end, { buffer = self.repl_input_bufnr })

    vim.api.nvim_create_autocmd("WinEnter", {
        group = self._augroup,
        buffer = self.repl_background_bufnr,
        callback = function()
            -- When we enter the background window we want to automatically
            -- enter a different window. The approach is:
            -- *  Entering from the repl input     => go to repl output
            -- *  Entering from the repl output    => go to last normal window
            -- *  Entering from last normal window => go to repl input
            -- This should hopefully make entering/leaving the REPL windows
            -- feel natural and work well with the user's existing keymaps.
            vim.api.nvim_set_current_win(
                (state.last_win == self.repl_input_winnr and self.repl_output_winnr)
                or (state.last_win == self.repl_output_winnr and state.last_normal_win)
                or (state.last_win == state.last_normal_win and self.repl_input_winnr)
                or state.last_win
            )
        end
    })

    vim.api.nvim_create_autocmd("WinClosed", {
        group = self._augroup,
        callback = function(e)
            local repl_wins = { self.repl_background_winnr, self.repl_input_winnr, self.repl_output_winnr }
            local repl_bufs = { self.repl_background_bufnr, self.repl_input_bufnr, self.repl_output_bufnr }

            if not vim.tbl_contains(repl_bufs, e.buf) then
                return
            end

            for _, winnr in ipairs(repl_wins) do
                if vim.api.nvim_win_is_valid(winnr) then
                    vim.api.nvim_win_close(winnr, true)
                end
            end
        end
    })

    vim.api.nvim_create_autocmd("WinResized", {
        group = self._augroup,
        callback = function()
            self:_fix_layout()
        end
    })
end

function jet_kernel:_fix_layout()
    if not vim.api.nvim_win_is_valid(self.repl_input_winnr)
        or not vim.api.nvim_win_is_valid(self.repl_output_winnr) then
        return
    end

    -- First, if we're in either the input or output window, resize the background
    -- according to the current window width
    local cur_win = vim.api.nvim_get_current_win()
    if cur_win == self.repl_output_winnr or cur_win == self.repl_input_winnr then
        vim.api.nvim_win_set_config(self.repl_background_winnr, {
            width = vim.api.nvim_win_get_width(cur_win),
        })
    end

    -- Now we're sure the background is the right size, set both input and output
    -- to match its width
    for _, win in ipairs({ self.repl_input_winnr, self.repl_output_winnr }) do
        vim.api.nvim_win_set_config(win, {
            width = vim.api.nvim_win_get_width(self.repl_background_winnr),
        })
    end

    -- TODO: if we've just resized the output window vertically, adjust the input
    -- window height accordingly
    -- if cur_win == self.repl_output_winnr then
    --     vim.api.nvim_win_set_config(self.repl_input_winnr, {
    --         height =
    --     })
    -- end

    local bg_height = vim.api.nvim_win_get_height(self.repl_background_winnr)
    local input_height = vim.api.nvim_win_get_height(self.repl_input_winnr)
    vim.api.nvim_win_set_config(self.repl_output_winnr, {
        -- We need to subtract 1 to account for the borders (the output's
        -- bottom border should overlap with the input's top border)
        height = bg_height - input_height - 2,
    })
end

function jet_kernel:_try_send_input()
    local code = table.concat(
        vim.api.nvim_buf_get_lines(self.repl_input_bufnr, 0, -1, false),
        "\n"
    )
    local callback = engine.is_complete(self.id, code)

    utils.listen(callback, {
        action = function(res)
            return res.status == "idle" and "exit"
                or res.type == "is_complete_reply" and "handle"
                or "retry"
        end,
        -- TODO: add a timeout here
        ---@param res Jet.Callback.IsComplete.Result
        handler = function(res)
            if res.data.status == "incomplete" then
                self:_continue_input(res.data.indent)
            else
                self:_send_input()
            end
        end,
        interval = 10,
    })
end

function jet_kernel:_send_input()
    local code = vim.api.nvim_buf_get_lines(self.repl_input_bufnr, 0, -1, false)
    self:_reset_indent()
    vim.api.nvim_buf_set_lines(self.repl_input_bufnr, 0, -1, false, {})
    self:execute(code)
    vim.api.nvim_win_set_config(self.repl_input_winnr, { height = 1 })
end

function jet_kernel:_continue_input(indent)
    local last_line = vim.fn.line("$") + 1
    vim.api.nvim_buf_set_lines(self.repl_input_bufnr, -1, -1, true, { "" })
    self:_set_indent((indent or "+") .. "  ", last_line - 1)
    vim.api.nvim_buf_call(self.repl_input_bufnr, function() vim.fn.cursor(last_line, 0) end)
    vim.api.nvim_win_set_config(self.repl_input_winnr, { height = last_line })
end

---@param fn fun(bufnr: number?)
function jet_kernel:_with_input_buf(fn)
    if vim.api.nvim_buf_is_valid(self.repl_input_bufnr) then
        fn(self.repl_input_bufnr)
    end
end

---@param fn fun(bufnr: number?)
function jet_kernel:_with_output_buf(fn)
    if vim.api.nvim_buf_is_valid(self.repl_output_bufnr) then
        fn(self.repl_output_bufnr)
    end
end

---@param fn fun(winnr: number?)
function jet_kernel:_with_input_win(fn)
    if vim.api.nvim_win_is_valid(self.repl_input_winnr) then
        fn(self.repl_input_winnr)
    end
end

---@param fn fun(winnr: number?)
function jet_kernel:_with_output_win(fn)
    if vim.api.nvim_win_is_valid(self.repl_output_winnr) then
        fn(self.repl_output_winnr)
    end
end

---@param msg Jet.Callback.Execute.Result
function jet_kernel:_handle_result(msg)
    if not msg.data then
        return
    end

    if msg.type == "execute_input" then
        self:_display_repl_text(msg.data.code .. "\n")
    elseif msg.type == "execute_result" then
        self:_display_repl_text(msg.data.data["text/plain"])
    elseif msg.type == "stream" then
        self:_display_repl_text(msg.data.text)
    elseif msg.type == "error" then
        self:_display_repl_text(msg.data.evalue)
    elseif msg.type == "input_request" then
        self:_display_repl_text(msg.data.prompt)
    elseif msg.type == "display_data" then
        self:_display_repl_text(vim.inspect(msg.data))
    end

    self:_scroll_to_end()
end

function jet_kernel:_reset_indent()
    self:_clear_indent(0, -1)
    self:_set_indent(self.indent.input, 0)
end

---@param indent string
---@param lnum number
function jet_kernel:_set_indent(indent, lnum)
    self:_with_input_buf(function(input_buf)
        vim.api.nvim_buf_set_extmark(input_buf, self._ns, lnum, 0, {
            -- TODO: add Jet highlight groups
            virt_text = { { indent .. " ", "FloatTitle" } },
            virt_text_pos = "inline",
            right_gravity = false,
        })
    end)
end

---@param line_start number
---@param line_end number
function jet_kernel:_clear_indent(line_start, line_end)
    self:_with_input_buf(function(input_buf)
        vim.api.nvim_buf_clear_namespace(input_buf, self._ns, line_start, line_end)
    end)
end

---@param prompt string[]
function jet_kernel:_set_prompt(prompt)
    if not prompt then
        return
    end
    self:_clear_indent(1, -1)
    vim.api.nvim_buf_set_lines(self.repl_input_bufnr, 0, -1, false, prompt)
end

---@param increment number
function jet_kernel:_get_history(increment)
    local new_index = self.history_index + increment
    local entry = self.history[new_index]
    if not entry then
        return
    end
    self.history_index = new_index
    return self.history[self.history_index]
end

function jet_kernel:_scroll_to_end()
    self:_with_output_buf(function(output_buf)
        vim.api.nvim_buf_call(output_buf, function()
            vim.fn.cursor(vim.fn.line("$"), 0)
        end)
    end)
end

---@param title string?
function jet_kernel:_set_title(title)
    title = title or (self.info and self.info.display_name)
    title = title or (self.info.language and self.info.language.name)

    if title then
        vim.api.nvim_win_set_config(self.repl_output_winnr, {
            title = title,
            title_pos = "center",
        })
    end
end

function jet_kernel:_set_filetype()
    self.filetype = utils.ext_to_filetype(self.info.language.file_extension)
        or self.info.language.name
        or self.info.language.file_extension
    vim.bo[self.repl_input_bufnr].filetype = self.filetype
end

---@param text string
function jet_kernel:_display_repl_text(text)
    if not text then
        return
    end

    vim.api.nvim_chan_send(self.repl_channel, text)
end

return jet_kernel
