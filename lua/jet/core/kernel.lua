---@diagnostic disable-next-line: different-requires
local engine = require("jet.core.rust")
local manager = require("jet.core.manager")
local utils = require("jet.core.utils")

---@class Jet.Kernel
---
---The kernel's unique Id, generated by the Rust engine when the kernel starts
---@field id Jet.Kernel.Id
---
---The filetype associated with the kernel's language.
---@field filetype string
---
---The history of executed code snippets
---@field history string[][]
---
---The current index in the history.
---@field history_index number
---
---Information about the kernel
---@field instance Jet.Kernel.Instance
---
---@field ui Jet.Ui.ReplFloat
local kernel = {}
kernel.__index = kernel

setmetatable(kernel, {
	---@return Jet.Kernel
	__call = function(self, ...)
		return self.start(...)
	end,
})

---@param spec_path Jet.Kernel.Spec.Path
function kernel.start(spec_path)
	local self = setmetatable({}, kernel)
	self.history = {}
	self.id, self.instance = engine.start_kernel(spec_path)
	manager.running[self.id] = self
	self.filetype = self:_filetype_get()
	self:init_repl()
	return self
end

function kernel:init_repl()
	if self.ui then
		error("UI already exists")
	end
	self.ui = require("jet.core.ui.repl_split").new():init(self)
end

function kernel:stop()
	-- Request kernel shutdown
	engine.request_shutdown(self.id)
	--- Remove from manager
	manager.running[self.id] = nil
end

---@param code string[]
---@param opts { complete: fun(), incomplete: fun() }
function kernel:if_complete(code, opts)
	utils.listen(engine.is_complete(self.id, table.concat(code, "\n")), {
		action = function(res)
			return res.status == "idle" and "exit" or res.type == "is_complete_reply" and "handle" or "retry"
		end,
		-- TODO: add a timeout here
		handler = function(res)
			local status = res and res.data and res.data.status
			if not status then
				return
			end
			-- There are more statusses then complete/incomplete. But we only
			-- ever give 'incomplete' special treatment.
			if status ~= "incomplete" then
				opts.complete()
			else
				opts.incomplete()
			end
		end,
		interval = 10,
	})
end

---@param code string[]
---@param callback fun(msg: Jet.Callback.Execute.Result)
---@param on_exit? fun()
function kernel:execute(code, callback, on_exit)
	if not self.id then
		error("Kernel is not active; use `start()` to activate the kernel.")
	end

	if vim.tbl_count(code) == 0 then
		return
	end

	self:history_append(code)

	utils.listen(engine.execute_code(self.id, table.concat(code, "\n"), {}), {
		action = function(res)
			return res.status == "idle" and "exit" or res.data and "handle" or "retry"
		end,
		handler = callback,
		-- handler = function(res)
		--     self:_msg_to_string(res)
		--     if callback then
		--         callback(res)
		--     end
		-- end,
		on_exit = on_exit,
		interval = 50,
	})
end

function kernel:send_from_buf()
	local mode = vim.fn.mode()

	local code = (
		mode == "n" and self.get_buf_text_normal().code
		or mode == "i" and self.get_buf_text_insert().code
		or mode:lower() == "v" and self.get_buf_text_visual().code
		or {}
	)

	self.ui:execute(code)
end

---@return Jet.GetExpr.Result
function kernel.get_buf_text_normal()
	local ft = vim.bo.filetype
	local ok, ft_module = pcall(require, "jet.filetype." .. ft)
	if ok and ft_module.get_expr then
		return ft_module.get_expr()
	end

	local line = vim.fn.line(".")
	local code = vim.api.nvim_buf_get_lines(0, line - 1, line, false)
	return {
		code = code,
	}
end

---@return Jet.GetExpr.Result
function kernel.get_buf_text_insert()
	return kernel.get_buf_text_normal()
end

---@return Jet.GetExpr.Result
function kernel.get_buf_text_visual()
	local start, stop = vim.fn.getpos("v"), vim.fn.getpos(".")
	-- local escape_keycode = "\27"
	-- vim.fn.feedkeys(escape_keycode, "L")
	-- vim.fn.cursor(math.min(vim.fn.nextnonblank(stop[2] + 1), stop[2]), 0)
	local code = vim.fn.getregion(start, stop, { type = vim.fn.mode() })
	return {
		-- TODO: add additional fields
		code = code,
	}
end

---@param increment number
---@return string[]
function kernel:history_get(increment)
	local new_index = self.history_index + increment
	self.history_index = math.max(1, math.min(new_index, #self.history + 1))
	return self.history[self.history_index] or {}
end

function kernel:history_append(code)
	table.insert(self.history, code)
	self.history_index = #self.history + 1
end

---Get the filetype for the kernel
---
---First uses the kernel language's file extension (if available), falling back
---to the kernel language name if that doesn't work.
---
---@return string
function kernel:_filetype_get()
	local file_extension = self.instance.info.language_info.file_extension

	local filetype = utils.ext_to_filetype(file_extension)

	if filetype then
		return filetype
	end

	-- Unfortunately vim.filetype.match() doesn't always seem to work.
	-- E.g. vim.print({ vim.filetype.match({ filename = "test.R" }) })
	-- The Jupyter protocol enforces that kernel specs must have a language, so
	-- we fall back to that if needed.
	local lang = self.instance.spec.language
	utils.log_debug(
		"Could not resolve kernel filetype for extension `%s`; falling back to language `%s`",
		file_extension,
		lang
	)

	return lang
end

return kernel
