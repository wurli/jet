---@diagnostic disable-next-line: different-requires
local engine = require("jet.core.engine")
local manager = require("jet.core.manager")
local utils = require("jet.core.utils")

---@class Jet.Kernel
---
---The kernel's unique Id, generated by the Rust engine when the kernel starts
---@field id Jet.Kernel.Id
---
---The filetype associated with the kernel's language.
---@field filetype string
---
---The history of executed code snippets
---@field history string[][]
---
---The current index in the history.
---@field history_index number
---
---Information about the kernel
---@field instance Jet.Kernel.Instance
---
---@field ui? Jet.Ui.ReplSplit | Jet.Ui.Notebook
local kernel = {}
kernel.__index = kernel

setmetatable(kernel, {
	---@return Jet.Kernel
	__call = function(self, ...)
		return self.start(...)
	end,
})

---@param spec_path Jet.Kernel.Spec.Path
function kernel.start(spec_path)
	local self = setmetatable({}, kernel)
	self.history = {}
	self.id, self.instance = engine.start_kernel(spec_path)
	manager.running[self.id] = self
	self.filetype = self:_filetype_get()
	return self
end

---@return string
function kernel:name()
	return self.instance.spec.display_name
end

---@return { icon: string, hl: string }?
function kernel:icon()
	if not self.filetype then
		return
	end

	local ok, mini_icons = pcall(require, "mini.icons")

	if not ok then
		return
	end

	local icon, hl, is_default = mini_icons.get("filetype", self.filetype)

	if is_default then
		return
	end

	return { icon = icon, hl = hl }
end

---@param type "repl" | "notebook"
---@param opts? Jet.Ui.Init.Opts
function kernel:init_ui(type, opts)
	if self.ui then
		error("UI already exists")
	end

	if type == "notebook" then
		self.ui = require("jet.core.ui.notebook").new():init(self, opts)
	elseif type == "repl" then
		self.ui = require("jet.core.ui.repl_split").new():init(self, opts)
	else
		error("Unrecognised UI type: " .. tostring(type))
	end
end

function kernel:stop()
	-- Request kernel shutdown
	engine.request_shutdown(self.id)
	--- Remove from manager
	manager.running[self.id] = nil
end

---@param code string[]
---@param opts { complete: fun(), incomplete: fun() }
function kernel:if_complete(code, opts)
	utils.listen(engine.is_complete(self.id, table.concat(code, "\n")), {
		action = function(res)
			return res.status == "idle" and "exit" or res.type == "is_complete_reply" and "handle" or "retry"
		end,
		-- TODO: add a timeout here
		handler = function(res)
			local status = res and res.data and res.data.status
			if not status then
				return
			end
			-- There are more statusses then complete/incomplete. But we only
			-- ever give 'incomplete' special treatment.
			if status ~= "incomplete" then
				opts.complete()
			else
				opts.incomplete()
			end
		end,
		interval = 10,
	})
end

---@param code string[]
---@param callback? fun(msg: Jet.Callback.Execute.Result)
---@param on_complete? fun()
function kernel:execute(code, callback, on_complete)
	if vim.tbl_count(code) == 0 then
		return
	end

	self:history_append(code)

	utils.listen(engine.execute_code(self.id, table.concat(code, "\n"), {}), {
		action = function(res)
			return res.status == "idle" and "exit" or res.data and "handle" or "retry"
		end,
		handler = callback,
		on_exit = on_complete,
		interval = 50,
	})
end

---@param callback fun(msg: Jet.Callback.Interrupt.Result)
---@param on_exit? fun()
function kernel:interrupt(callback, on_exit)
	utils.listen(engine.interrupt(self.id), {
		action = function(res)
			if res.status == "idle" then
				return "exit"
			elseif res.data then
				return "handle"
			else
				return "retry"
			end
		end,
		handler = callback,
		on_exit = on_exit,
		interval = 50,
	})
end

---@param increment number
---@return string[]?
function kernel:history_get(increment)
	if not self.history_index then
		return
	end

	local new_index = self.history_index + increment
	self.history_index = math.max(1, math.min(new_index, #self.history + 1))
	return self.history[self.history_index] or {}
end

function kernel:history_append(code)
	table.insert(self.history, code)
	self.history_index = #self.history + 1
end

---Get the filetype for the kernel
---
---First uses the kernel language's file extension (if available), falling back
---to the kernel language name if that doesn't work.
---
---@return string
function kernel:_filetype_get()
	return utils.resolve_filetype({
		extension = self.instance.info.language_info.file_extension,
		language = self.instance.spec.language,
	})
end

return kernel
