---@diagnostic disable-next-line: different-requires
local engine = require("jet.core.rust")
local manager = require("jet.core.manager")
local utils = require("jet.core.utils")

---@class Jet.Kernel
---
---The kernel's unique Id, generated by the Rust engine when the kernel starts
---@field id Jet.Kernel.Id
---
---The filetype associated with the kernel's language
---@field filetype string
---
---The history of executed code snippets
---@field history string[][]
---
---The current index in the history.
---@field history_index number
---
---Information about the kernel
---@field instance Jet.Kernel.Instance
---
---@field ui Jet.Ui.Repl
local kernel = {}
kernel.__index = kernel

setmetatable(kernel, {
    ---@return Jet.Kernel
    __call = function(self, ...)
        return self.start(...)
    end,
})

---@param spec_path Jet.Kernel.Spec.Path
function kernel.start(spec_path)
    local self = setmetatable({}, kernel)
    self.history = {}
    self.id, self.instance = engine.start_kernel(spec_path)
    -- self:ui_show()
    manager.running[self.id] = self
    self:init_repl()
    return self
end

function kernel:init_repl()
    if self.ui then
        error("UI already exists")
    end
    self.ui = require("jet.core.ui.repl").init(self)
end

function kernel:stop()
    -- Request kernel shutdown
    engine.request_shutdown(self.id)
    --- Remove from manager
    manager.running[self.id] = nil
end

---@param code string[]
---@param opts { complete: fun(), incomplete: fun() }
function kernel:if_complete(code, opts)
    utils.listen(engine.is_complete(self.id, table.concat(code, "\n")), {
        action = function(res)
            return res.status == "idle" and "exit"
                or res.type == "is_complete_reply" and "handle"
                or "retry"
        end,
        -- TODO: add a timeout here
        handler = function(res)
            local status = res and res.data and res.data.status
            if not status then
                return
            end
            -- There are more statusses then complete/incomplete. But we only
            -- ever give 'incomplete' special treatment.
            if status ~= "incomplete" then
                opts.complete()
            else
                opts.incomplete()
            end
        end,
        interval = 10,
    })
end

---@param code string[]
---@param callback fun(msg: Jet.Callback.Execute.Result)
---@param on_exit? fun()
function kernel:execute(code, callback, on_exit)
    if not self.id then
        error("Kernel is not active; use `start()` to activate the kernel.")
    end

    if vim.tbl_count(code) == 0 then
        return
    end

    self:history_append(code)

    utils.listen(engine.execute_code(self.id, table.concat(code, "\n"), {}), {
        action = function(res)
            return res.status == "idle" and "exit" or res.data and "handle" or "retry"
        end,
        handler = callback,
        -- handler = function(res)
        --     self:_msg_to_string(res)
        --     if callback then
        --         callback(res)
        --     end
        -- end,
        on_exit = on_exit,
        interval = 50,
    })
end

function kernel:send_from_buf()
    local mode = vim.fn.mode()

    local code = (
        mode == "n" and self.get_buf_text_normal().code
        or mode == "i" and self.get_buf_text_insert().code
        or mode:lower() == "v" and self.get_buf_text_visual().code
        or {}
    )

    self.ui:execute(code)
end

---@return Jet.GetExpr.Result
function kernel.get_buf_text_normal()
    local ft = vim.bo.filetype
    local ok, ft_module = pcall(require, "jet.filetype." .. ft)
    if ok and ft_module.get_expr then
        return ft_module.get_expr()
    end

    local line = vim.fn.line(".")
    local code = vim.api.nvim_buf_get_lines(0, line - 1, line, false)
    return {
        code = code,
    }
end

---@return Jet.GetExpr.Result
function kernel.get_buf_text_insert()
    return kernel.get_buf_text_normal()
end

---@return Jet.GetExpr.Result
function kernel.get_buf_text_visual()
    local start, stop = vim.fn.getpos("v"), vim.fn.getpos(".")
    -- local escape_keycode = "\27"
    -- vim.fn.feedkeys(escape_keycode, "L")
    -- vim.fn.cursor(math.min(vim.fn.nextnonblank(stop[2] + 1), stop[2]), 0)
    local code = vim.fn.getregion(start, stop, { type = vim.fn.mode() })
    return {
        -- TODO: add additional fields
        code = code,
    }
end

---@param increment number
---@return string[]
function kernel:history_get(increment)
    local new_index = self.history_index + increment
    self.history_index = math.max(1, math.min(new_index, #self.history + 1))
    return self.history[self.history_index] or {}
end

function kernel:history_append(code)
    table.insert(self.history, code)
    self.history_index = #self.history + 1
end

---@return string?
function kernel:_filetype_get()
    local spec_lang = self.instance.spec.language
    local lang = self.instance.info and self.instance.info.language_info or {}
    return utils.ext_to_filetype(lang.file_extension) or lang.name or lang.file_extension or spec_lang
end

return kernel
