---@diagnostic disable-next-line: different-requires
local engine = require("jet.core.rust")
local manager = require("jet.core.manager")
local utils = require("jet.core.utils")

---@class Jet.Kernel
---
---The kernel's unique Id, generated by the Rust engine when the kernel starts
---@field id Jet.Kernel.Id
---
---The filetype associated with the kernel's language.
---@field filetype string
---
---The history of executed code snippets
---@field history string[][]
---
---The current index in the history.
---@field history_index number
---
---Information about the kernel
---@field instance Jet.Kernel.Instance
---
---@field ui Jet.Ui.ReplSplit
local kernel = {}
kernel.__index = kernel

setmetatable(kernel, {
	---@return Jet.Kernel
	__call = function(self, ...)
		return self.start(...)
	end,
})

---@param spec_path Jet.Kernel.Spec.Path
function kernel.start(spec_path)
	local self = setmetatable({}, kernel)
	self.history = {}
	self.id, self.instance = engine.start_kernel(spec_path)
	manager.running[self.id] = self
	self.filetype = self:_filetype_get()
	self:init_repl()
	return self
end

---@return string
function kernel:name()
	return self.instance.spec.display_name
end

---@return { icon: string, hl: string }?
function kernel:icon()
	if not self.filetype then
		return
	end

	local ok, mini_icons = pcall(require, "mini.icons")

	if not ok then
		return
	end

	local icon, hl, is_default = mini_icons.get("filetype", self.filetype)

	if is_default then
		return
	end

	return { icon = icon, hl = hl }
end

function kernel:init_repl()
	if self.ui then
		error("UI already exists")
	end
	self.ui = require("jet.core.ui.repl_split").new():init(self)
end

function kernel:stop()
	-- Request kernel shutdown
	engine.request_shutdown(self.id)
	--- Remove from manager
	manager.running[self.id] = nil
end

---@param code string[]
---@param opts { complete: fun(), incomplete: fun() }
function kernel:if_complete(code, opts)
	utils.listen(engine.is_complete(self.id, table.concat(code, "\n")), {
		action = function(res)
			return res.status == "idle" and "exit" or res.type == "is_complete_reply" and "handle" or "retry"
		end,
		-- TODO: add a timeout here
		handler = function(res)
			local status = res and res.data and res.data.status
			if not status then
				return
			end
			-- There are more statusses then complete/incomplete. But we only
			-- ever give 'incomplete' special treatment.
			if status ~= "incomplete" then
				opts.complete()
			else
				opts.incomplete()
			end
		end,
		interval = 10,
	})
end

---@param code string[]
---@param callback fun(msg: Jet.Callback.Execute.Result)
---@param on_exit? fun()
function kernel:execute(code, callback, on_exit)
	if vim.tbl_count(code) == 0 then
		return
	end

	self:history_append(code)

	utils.listen(engine.execute_code(self.id, table.concat(code, "\n"), {}), {
		action = function(res)
			return res.status == "idle" and "exit" or res.data and "handle" or "retry"
		end,
		handler = callback,
		-- handler = function(res)
		--     self:_msg_to_string(res)
		--     if callback then
		--         callback(res)
		--     end
		-- end,
		on_exit = on_exit,
		interval = 50,
	})
end

function kernel:send_from_buf()
	local mode = vim.fn.mode()

	local code = (
		mode == "n" and self.get_buf_text_normal()
		or mode == "i" and self.get_buf_text_insert()
		or mode:lower() == "v" and self.get_buf_text_visual()
		or {}
	)

	-- We defer to the UI to decide the details of how execution happens, e.g.
	-- what to show the user etc. At some point the UI should also tell the
	-- kernel to actually perform the execution.
	self.ui:execute(code)
end

---@return Jet.GetExpr.Result?
function kernel.get_buf_text_normal()
	local ft = vim.bo.filetype
	---@type boolean, Jet.Extension.FileType
	local ok, ft_module = pcall(require, "jet.filetype." .. ft)
	if ok and ft_module.get_expr then
		return ft_module.get_expr({
			bufnr = vim.fn.bufnr(),
			winnr = vim.fn.winnr(),
			cursor_col = vim.fn.col("."),
			cursor_row = vim.fn.line("."),
		})
	end

	local line = vim.fn.line(".")
	local code = vim.api.nvim_buf_get_lines(0, line - 1, line, false)
	return {
		--TODO: more fields
		code = code,
	}
end

---@return Jet.GetExpr.Result?
function kernel.get_buf_text_insert()
	return kernel.get_buf_text_normal()
end

---@return Jet.GetExpr.Result?
function kernel.get_buf_text_visual()
	local start, stop = vim.fn.getpos("v"), vim.fn.getpos(".")
	local code = vim.fn.getregion(start, stop, { type = vim.fn.mode() })
	return {
		bufnr = vim.fn.bufnr(),
		winnr = vim.fn.winnr(),
		--TODO: use treesitter if available
		filetype = vim.bo.filetype,
		start_row = start[2],
		start_col = start[3],
		end_row = stop[2],
		end_col = stop[3],
		code = code,
	}
end

---@param callback fun(msg: Jet.Callback.Interrupt.Result)
---@param on_exit? fun()
function kernel:interrupt(callback, on_exit)
	utils.listen(engine.interrupt(self.id), {
		action = function(res)
			if res.status == "idle" then
				return "exit"
			elseif res.data then
				return "handle"
			else
				return "retry"
			end
		end,
		handler = callback,
		on_exit = on_exit,
		interval = 50,
	})
end

---@param increment number
---@return string[]?
function kernel:history_get(increment)
	if not self.history_index then
		return
	end

	local new_index = self.history_index + increment
	self.history_index = math.max(1, math.min(new_index, #self.history + 1))
	return self.history[self.history_index] or {}
end

function kernel:history_append(code)
	table.insert(self.history, code)
	self.history_index = #self.history + 1
end

---Get the filetype for the kernel
---
---First uses the kernel language's file extension (if available), falling back
---to the kernel language name if that doesn't work.
---
---@return string
function kernel:_filetype_get()
	return utils.resolve_filetype({
		extension = self.instance.info.language_info.file_extension,
		language = self.instance.spec.language,
	})
end

return kernel
