# Support for frontend-side RPC methods

> <https://github.com/posit-dev/ark/pull/195>
> 
> * Author: @lionel-
> * State: MERGED
> * Labels: 

Ark side of https://github.com/posit-dev/positron/pull/2019.
Progress towards https://github.com/posit-dev/positron/issues/1542
Addresses https://github.com/posit-dev/positron/issues/2018

- Implements a mechanism for calling frontend-side RPC methods via StdIn.

- User interrupts and protocol errors are handled gracefully: control is given back to R and the stdin socket thread starts a new iteration.

- Adds basic rstudioapi shims for `.rs.api.getSourceEditorContext()` and `.rs.api.getActiveDocumentContext()`. These now return the path of the currently active editor, which enables functions like `usethis::use_r()` and `usethis::use_test()` to work as expected.

  The shims are implemented in `modules/rstudioapi`. The files in this folder are sourced into an environment attached on the search path as `tools:rstudio`. We also override `rstudioapi::isAvailable()` on load to trick it into believing it's running under RStudio.


## @lionel- at 2024-01-05T16:12:44Z

oops, internal rstudioapi functions are ending up on the search path, I'll adjust that

## @lionel- at 2024-01-08T08:56:12Z

@DavisVaughan I meant to ask you for a review here instead of the positron PR but of course your comments are welcome there as well!

## @lionel- at 2024-01-08T11:34:04Z

> oops, internal rstudioapi functions are ending up on the search path, I'll adjust that

I've added simple tools to detect roxygen-like tags `#' @export` in sourced file. We now use that to populate the rstudioapi environment on the search path.

In an ulterior PR I'll use the same trick to populate the public positron env, this way we won't need the private/public folder split any longer.

## @lionel- at 2024-01-08T15:36:31Z

With the last commit we now check method replies against the OpenRPC contract. This is done by deserialising the JSON to the corresponding Rust type, even though we discard the result immediately and deserialise to `RObject` again. This is a bit redundant but seems ok for now. We might want to do better if we start sending large payloads in these frontend replies.

The deserialisation is supported by this util that is now automatically generated by `generate-comm.ts`:

```rust
/**
* Conversion of JSON values to frontend RPC Reply types
*/
pub fn frontend_frontend_reply_from_value(
	reply: serde_json::Value,
	request: &FrontendFrontendRpcRequest,
) -> anyhow::Result<FrontendFrontendRpcReply> {
	match request {
		FrontendFrontendRpcRequest::LastActiveEditorContext => Ok(FrontendFrontendRpcReply::LastActiveEditorContextReply(serde_json::from_value(reply)?)),
		FrontendFrontendRpcRequest::DebugSleep(_) => Ok(FrontendFrontendRpcReply::DebugSleepReply),
	}
}
```